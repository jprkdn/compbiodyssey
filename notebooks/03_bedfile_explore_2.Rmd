---
title: "BED File Analysis Pt. 2"
output: html_document
---

# Week 1: Practice with BED files part 2

This notebook is designed to test additional manipulations of BED files with 15 additional prompts generated by ChatGPT for me to review and play with. Following my practice with tidyverse vs. base R, I am looking at new prompts with a new BED file.

---

## Load libraries
```{r, setup, message=FALSE, warning=FALSE}
library(tidyverse)
```
##when I run this chunk, it loads tidyverse
---

##Load the BED file
```{r}
bed_file = read_tsv("/Users/Jay/Documents/My Projects/compbio-projects/compbiodyssey/data/interview_bed_file.bed",col_names = FALSE) %>%
  setNames(c("chrom","start","end","name","score","strand"))
head(bed_file)
```

---

###How many rows are there in the bed file?
```{r}
dim(bed_file)[1]

```
---

##Tidyverse answer
```{r}
bed_file %>% summarize(n()) %>% pull()

```

---

###How many unique chromosomes are present?
```{r}
length(unique(bed_file$chrom))

```

## Tidyverse answer
```{r}
bed_file %>% select(chrom) %>%
  distinct() %>%
  summarize(n())
```

---
##Which chromosome has the most entries
```{r}
sort(table(bed_file$chrom),decreasing = TRUE)[1]

```

---

## Now in tidyverse
```{r}
bed_file %>% count(chrom) %>%
  arrange(desc(n)) %>%
  slice(1) %>%
  pull(chrom)
 
```

---

## What is the average region length?
```{r}
mean(bed_file$end - bed_file$start)

```

---

## Now in tidyverse
```{r}
bed_file %>% mutate(length = end - start) %>%
  summarize(mean(length)) %>%
  pull()

```
## Filter for regions on the '+' strand and on chr1
```{r}
unlist(bed_file[which(bed_file$strand=="+" & bed_file$chrom=="chr1"),"name"])

```

---

## Now in tidyverse

```{r}
bed_file %>% filter(strand=="+" & chrom == "chr1") %>%
  pull(name)
```

---

##Find the top 5 highest scoring regions. Do it in tidyverse because I actually forgot how to do it in base R.

```{r}
bed_file %>% slice_max(score,n = 5) %>%
  pull(name)
  

bed_file %>% arrange(desc(score)) %>%
  head(5) %>%
  pull(name)
```


---

##Count how many regions fall in each strand. I also am going straight to tidyverse and here's three ways of doing it. The first is by subsetting + and - and then just summarizing. The second is counting but assumes there's one region per row. The 2nd is universal.

```{r}
bed_file %>% filter(strand=="+") %>%
  count(name) %>%
  summarize(n()) %>%
  pull()

bed_file %>% filter(strand=="-") %>%
  count(name) %>%
  summarize(n()) %>%
  pull()

bed_file %>% count(strand)

bed_file %>% group_by(strand) %>%
  summarize(n_distinct(name))
```

---

## Add a column for region length

```{r}
bed_file = bed_file %>% mutate(length = end-start)

```

---

### What is the total genomic coverage per chromosome?
Let's break this problem down
For each chromosome, I want to calculate "coverage", which I guess means the percentage of bases that are assigned to at least one region. Let's figure that out.

This isn't true, it's about the number of unique bases. That's way easier.
```{r}
tot_base = bed_file %>% group_by(chrom) %>%
  summarize(tot_base = max(end)-min(start))
# wrong because this is the span not the coverage

tot_gaps = bed_file %>% arrange(chrom,start) %>%
  group_by(chrom) %>%
  mutate(tot_gap = lead(start)-end) %>%
  filter(tot_gap>0) %>%
  summarize(tot_gap = sum(tot_gap,na.rm = TRUE))
# this is the total gap

# subtract to get total coverage
tot_cov = tot_base %>% pull(tot_base) - tot_gaps %>% pull(tot_gap)

# Can also use this to solve the previous problem:
tot_pct_cov = tot_cov/tot_base %>% pull(tot_base)

tot_cov
tot_pct_cov

```

---

# Calculate the average interval length per chromosome

```{r}
bed_file %>% arrange(chrom,start) %>%
  mutate(interval = end - start)
  group_by(chrom) %>%
  summarize(avg_ilength = mean(interval))

```

---

# Count the number of intervals that are at least 1000 base pairs long.
I'm gonna do this per chromosome and total
```{r}
bed_file %>% arrange(chrom,start) %>%
  mutate(interval = end - start) %>%
  filter(interval > 1000) %>%
  summarize(n())

bed_file %>% arrange(chrom,start) %>%
  mutate(interval = end - start) %>%
  filter(interval > 1000) %>%
  group_by(chrom) %>%
  summarize(n())

```

---

## Find the interval with the maximum length on each chromosome.

```{r}
bed_file %>% arrange(chrom,start) %>%
  mutate(interval = end - start) %>%
  group_by(chrom) %>%
  slice_max(interval)
  
```

---

## Find the median interval length per chromosome.

```{r}
bed_file %>% arrange(chrom,start) %>%
  mutate(interval = end - start) %>%
  group_by(chrom) %>%
  summarize(median(interval))

```
---

# Find the number of intervals that overlap with at least one other interval on the same chromosome

```{r}
bed_file %>% arrange(chrom,start) %>%
  group_by(chrom) %>%
  mutate(overlap1 = lag(end)-start) %>%
  mutate(overlap2 = end-lead(start)) %>%
  filter(overlap1>0 | overlap2>0) %>%
  summarize(n())

```

---

# Identify all chromosomes that contain overlapping intervals and return them as a vector.

I interpret this as meaning identify all chromosomes where there's intervals that overlap. This means that I can probably just do the same thing again, and then return the vector of chromosomes.
```{r}
bed_file %>% arrange(chrom,start) %>%
  group_by(chrom) %>%
  mutate(overlap1 = lag(end) - start) %>%
  mutate(overlap2 = end - lead(start)) %>%
  filter(overlap1>0 | overlap2 > 0) %>%
  summarize(n()) %>%
  pull(chrom)

```


